DECLARE FUNCTION ClosestColor% (PixelRed%, PixelGreen%, PixelBlue%)
DECLARE SUB LoadAsm ()
DECLARE SUB MemCopyBD (FromSeg%, FromOff%, ToSeg%, ToOff%, Bytes%)
DECLARE SUB OPENBMP (Filename$)
''''''''''''''''''''''''''''''''''''''''
' Program    : Loads BMP Files         '
' Name       : OPENBMP Version 0.5     '
' Programmer : Yousuf Philips          '
' Company    : Y P I                   '
' Updated On : 12th of June 1999       '
' Email - [philipz85@hotmail.com]      '
' [http://members.xoom.com/Philipz/]   '
''''''''''''''''''''''''''''''''''''''''

'/*               Do not edit this file if you distribute it.              */'
'/*  (c) Copyrighted by YPI in 1998 | All Rights Reserved | Public Domain  */'

'/* This program has been created by YPI (Basic Programming Incorporation) */'
'/* as a utility to load Windows 3.x & OS/2 1.x BMP and DIB files.         */'

'/* Version 0.3 Released On [12th of Sept. 1998]                           */'
'/*         * Loads all Windows BMPs [Compressed & Uncompressed]           */'

'/* Version 0.4 Released On [29th of Dec. 1998]                            */'
'/*         * 24-Bit loading in color [Thanks to 24BITBMP.BAS (YPI)]       */'
'/*         * Loading of 4 & 8-Bit Images was increased                    */'

'/* Version 0.5 Released On [12th of June 1999]                            */'
'/*         * Program rewritten from scratch                               */'
'/*         * Size of code is smaller than Version 0.4                     */'
'/*         * Scrolling of large 8-Bit images                              */'
'/*         * Loads OS/2 Ver 1.0 BMPs                                      */'
'/*         * Loads 16-bit Images                                          */'
'/*         * Loads 16 & 24-bit Images in grayscale or color               */'
'/*         * 8-Bit loading was increased %                                */'
'/*         * 8-Bit RLE loading was increased %                            */'
'/*         * 4-Bit loading was increased %                                */'
'/*         * 4-Bit RLE loading was increased %                            */'
'/*         * 8-Bit loading was increased %                                */'

'/* I would like to give special thanks to Steve Demo for his color palette*/'
'/* and Angelo Mottola for his help with assembly.                         */'

'/* If you use any of this code in your program then you must credit YPI.  */'
'/* YPI has created an assortment of graphics viewers and players and they */'
'/* can all be found at <http://members.xoom.com/Philipz/>                 */'


TYPE BMPHeader
   ValidID AS STRING * 2          '/* Must be 'BM'
   SizeOfFile AS LONG             '/* Size of entire file in bytes
   Reserved AS LONG               '/* Four empty bytes
   OffsetOfBitMap AS LONG         '/* The location in the file where the
                                  '   image data is located
END TYPE

TYPE OS2Ver1InfoHeader
   SizeOfHeader AS LONG           '/* Size of Information Header [12]
   Widthz AS INTEGER              '/* Width of image in pixels
   Heightz AS INTEGER             '/* Height of image in pixels
   Planes AS INTEGER              '/* Number of Planes. Must be '1'
   BitsPerPixel AS INTEGER        '/* Number of bits per pixel
                                  ' Possible values are 1, 4, 8, 16, 24, 32
END TYPE

TYPE WindowsInfoHeader
   SizeOfHeader AS LONG        '/* Size of Information Header [40]
   Widthz AS LONG              '/* Width of image in pixels
   Heightz AS LONG             '/* Height of image in pixels
   Planes AS INTEGER           '/* Number of Planes. Must be '1'
   BitsPerPixel AS INTEGER     '/* Number of bits per pixel
                               ' Possible values are 1, 4, 8, 16, 24, 32
   CompressMethod AS LONG      '/* Compression Method
                               ' 0 - Uncompressed
                               ' 1 - 8 Bit RLE Compression
                               ' 2 - 4 Bit RLE Compression
   ImageSizeInBytes AS LONG    '/* Size of image in bytes
   HorizontalResol AS LONG     '/* Horizontal Resolution
   VerticalResol AS LONG       '/* Vertical Resolution
   ColorsUsed AS LONG          '/* Number of Colors used | 0 - All Used
   ImportantColors AS LONG     '/* Number of Important Colors
END TYPE

'$DYNAMIC

DEFINT A-Z
DIM SHARED ASM$, ArrayNo, ColorDif
DIM SHARED PixelArray(2000, 3), ColorPalette(255, 3)

CLS
FILES "*.bmp"

PRINT " Fast BMP Viewer for QBASIC - OPENBMP Ver 0.5"
PRINT " (c) YPI (BASIC Programming Incorporation) 1998-1999"
PRINT " Please Send Comments & Suggestions To <philipz85@hotmail.com>"
PRINT " Use The Arrow Keys To Scroll Large 8-Bit Images"

Filename$ = "tools.bmp"
IF RIGHT$(UCASE$(Filename$), 4) <> ".BMP" THEN
   Filename$ = Filename$ + ".BMP"
END IF
CALL LoadAsm
CALL OPENBMP(Filename$)





REDIM Picture(4447) AS INTEGER

GET (0, 0)-(69, 246), Picture
DEF SEG = VARSEG(Picture(0))
BSAVE "tools.bin", 0, 4448 * 2
DEF SEG

REM $STATIC
FUNCTION ClosestColor (PixelRed, PixelGreen, PixelBlue)

Movement = ColorDif
FOR PixelArraySearch = 1 TO ArrayNo
   IF PixelBlue >= PixelArray(PixelArraySearch, 1) - ColorDif AND PixelBlue <= PixelArray(PixelArraySearch, 1) + ColorDif THEN
      IF PixelGreen >= PixelArray(PixelArraySearch, 2) - ColorDif AND PixelGreen <= PixelArray(PixelArraySearch, 2) + ColorDif THEN
         IF PixelRed >= PixelArray(PixelArraySearch, 3) - ColorDif AND PixelRed <= PixelArray(PixelArraySearch, 3) + ColorDif THEN
            ClosestColor = PixelArray(PixelArraySearch, 0)
            EXIT FUNCTION
         END IF
      END IF
   END IF
NEXT PixelArraySearch

DO
    FOR Loopsz = 0 TO 255
       IF PixelBlue >= (ColorPalette(Loopsz, 3) - Movement) AND PixelBlue <= (ColorPalette(Loopsz, 3) + Movement) THEN
          IF PixelGreen >= (ColorPalette(Loopsz, 2) - Movement) AND PixelGreen <= (ColorPalette(Loopsz, 2) + Movement) THEN
             IF PixelRed >= (ColorPalette(Loopsz, 1) - Movement) AND PixelRed <= (ColorPalette(Loopsz, 1) + Movement) THEN
                IF ColorPalette(Loopsz, 1) = ColorPalette(Loopsz, 2) AND ColorPalette(Loopsz, 2) = ColorPalette(Loopsz, 3) AND Movement > 3 THEN
                   IF PixelBlue = PixelGreen AND PixelBlue = PixelRed THEN
                      ClosestColor = Loopsz
                      IF ArrayNo < 2000 THEN
                         ArrayNo = ArrayNo + 1
                         PixelArray(ArrayNo, 1) = PixelBlue
                         PixelArray(ArrayNo, 2) = PixelGreen
                         PixelArray(ArrayNo, 3) = PixelRed
                         PixelArray(ArrayNo, 0) = Loopsz
                      END IF
                      EXIT FUNCTION
                   END IF
                ELSE
                   ClosestColor = Loopsz
                   IF ArrayNo < 2000 THEN
                      ArrayNo = ArrayNo + 1
                      PixelArray(ArrayNo, 1) = PixelBlue
                      PixelArray(ArrayNo, 2) = PixelGreen
                      PixelArray(ArrayNo, 3) = PixelRed
                      PixelArray(ArrayNo, 0) = Loopsz
                   END IF
                   EXIT FUNCTION
                END IF
             END IF
          END IF
       END IF
    NEXT Loopsz
    Movement = Movement + 1
LOOP

END FUNCTION

SUB LoadAsm

'/* Assembly Used To Display 8-Bit Images (c) YPI 1999                     */'
ASM$ = ASM$ + CHR$(&H55) + CHR$(&H89) + CHR$(&HE5) + CHR$(&H1E) + CHR$(&HC5)
ASM$ = ASM$ + CHR$(&H76) + CHR$(&HC) + CHR$(&HC4) + CHR$(&H7E) + CHR$(&H8)
ASM$ = ASM$ + CHR$(&H8B) + CHR$(&H4E) + CHR$(&H6) + CHR$(&H89) + CHR$(&HCB)
ASM$ = ASM$ + CHR$(&H81) + CHR$(&HE3) + CHR$(&H3) + CHR$(&H0) + CHR$(&HC1)
ASM$ = ASM$ + CHR$(&HE9) + CHR$(&H2) + CHR$(&HF3) + CHR$(&H66) + CHR$(&HA5)
ASM$ = ASM$ + CHR$(&H81) + CHR$(&HFB) + CHR$(&H0) + CHR$(&H0) + CHR$(&H74)
ASM$ = ASM$ + CHR$(&H4) + CHR$(&H89) + CHR$(&HD9) + CHR$(&HF3) + CHR$(&HA4)
ASM$ = ASM$ + CHR$(&H1F) + CHR$(&H5D) + CHR$(&HCA) + CHR$(&HA) + CHR$(&H0)
'PUSH BP | MOV BP, SP | PUSH DS | LDS SI,[BP+0Ch] | LES DI,[BP+08h]
'MOV CX,[BP+06h] | MOV BX, CX | AND BX,03h | SHR CX,02h | REP MOVSD
'CMP BX,0h | JE FINISH | MOV CX, BX | REP MOVSB | FINISH: | POP DS
'POP BP | RETF 0Ah

END SUB

'/* Memory Copying Routine To Copy Bytes From One Location To Another      */'
SUB MemCopyBD (FromSeg, FromOff, ToSeg, ToOff, Bytes)

 DEF SEG = VARSEG(ASM$)
    CALL ABSOLUTE(BYVAL FromSeg, BYVAL FromOff, BYVAL ToSeg, BYVAL ToOff, BYVAL Bytes, SADD(ASM$))
 DEF SEG

END SUB

SUB OPENBMP (Filename$)

DIM BMPHeader AS BMPHeader
DIM OS2Ver1InfoHeader AS OS2Ver1InfoHeader
DIM WindowsInfoHeader AS WindowsInfoHeader
DIM Word AS INTEGER
DIM ImageWidth AS LONG
DIM ImageHeight AS LONG

CLS
OPEN Filename$ FOR BINARY AS #255
IF LOF(255) = 0 THEN
   PRINT " File Is Empty"
   CLOSE : KILL Filename$
   EXIT SUB
END IF

GET #255, , BMPHeader
IF BMPHeader.ValidID <> "BM" THEN
   PRINT " Invalid BMP File"
   CLOSE : EXIT SUB
END IF

GET #255, , Word
SEEK #255, LOC(255) - 1
IF Word = 12 THEN
   GET #255, , OS2Ver1InfoHeader
   ImageWidth = OS2Ver1InfoHeader.Widthz
   ImageHeight = OS2Ver1InfoHeader.Heightz
   BitsPerPixel = OS2Ver1InfoHeader.BitsPerPixel
   Compression = 0
   BytesPerPalette = 3
ELSEIF Word = 40 THEN
   GET #255, , WindowsInfoHeader
   ImageWidth = WindowsInfoHeader.Widthz
   ImageHeight = WindowsInfoHeader.Heightz
   BitsPerPixel = WindowsInfoHeader.BitsPerPixel
   Compression = WindowsInfoHeader.CompressMethod
   BytesPerPalette = 4
END IF

IF BitsPerPixel = 32 THEN
   PRINT " 32-bit Images Can't Be Displayed | Please send this image to philipz85@hotmail.com"
   CLOSE : EXIT SUB
END IF

IF BitsPerPixel > 8 THEN
   PRINT " Show"; BitsPerPixel; "Bit Image In Grayscale or Color [G|C]"
   DO
      Wait$ = INPUT$(1)
   LOOP UNTIL UCASE$(Wait$) = "G" OR UCASE$(Wait$) = "C"
   IF UCASE$(Wait$) = "G" THEN
      SCREEN 13
      Greyscale = 1
      OUT &H3C8, 0
      FOR Loops = 0 TO 255
         OUT &H3C9, Loops \ 4
         OUT &H3C9, Loops \ 4
         OUT &H3C9, Loops \ 4
      NEXT Loops
   ELSE
      PRINT " How Good To You Want The Quality Of The Picture [0-5]"
      PRINT " [0] - Best Quality & Slow [5] - OK Quality & Fast"
      Wait$ = INPUT$(1)
      ColorDif = VAL(Wait$)
      Greyscale = 0
      SCREEN 13
      '/* An excellent color palette from PALSTUFF.BAS [Graphics.abc|09/1995] */'
      Change$ = "#####M#M##MMM##M#MM8#MMM88888b8b88bbb88b8bbb8bbb+++"
      Change$ = Change$ + "...222555999===@@@DDDHHHKKKOOOSSSVVVZZZ^^^bbb3##8##"
      Change$ = Change$ + "=##?&&B**E--H11K55N88Q<<T@@XDDZII]NN_SSbYY3+#8-#=/#"
      Change$ = Change$ + "B2#G4#L6#Q9#V;#\>#\B*]F2^K:_OA`TIaXQb]Y33#66#99#<<#"
      Change$ = Change$ + "??#BB#EE#HH#LL#OO#RR#UU#XX#[[#^^#bb##8%#:(#<,#?/#A3"
      Change$ = Change$ + "#C7#F:#H>#KB#ME#OI#RM#TP#WT#YX#\\YbYRbQJbJG^GDZDAWA"
      Change$ = Change$ + ">S>;O;8L85H52E2/A/,=,):)&6&$3#YbbQbbJbbE__A\\=ZZ:VV"
      Change$ = Change$ + "7RR5NN2JJ0FF-BB*>>(::%66#33Y^bQ[bJXbBUb:Rb3Ob+Mb#Jb"
      Change$ = Change$ + "#F\#BV#>P#:J#6D#3?#/9#,3YYbQRbJJbEE_@@\<<Y88V55R33N"
      Change$ = Change$ + "11J..F,,B**>'':%%6##3/@$2B#5D#8F#;H#>J#AL#DN#GP#JR#"
      Change$ = Change$ + "MT#PV#SX#VZ#Y\#]_#bYb`S`^N^\H\ZCZX=XV8VT3UP0QL.MH+I"
      Change$ = Change$ + "D(EA&A<%<7$73#3-+&1-'5/):2+;3+=4,?5-@6-B7.D8/E9/G:0"
      Change$ = Change$ + "I;1J<1L=2N>3O?3Q@4SA5UB6VD8WF;XH>YJAZMD[OG\QJ]SM^VP"
      Change$ = Change$ + "_XS`ZVb]ZZ##X)#W0#U6#T;#S@#RF#PJ#ON#CN#6M#*M##L(#K3"
      Change$ = Change$ + "#K?#KH#FL#>M#5M#-N6#Q>#QD#QL#QQ#NQ#FQ#@Q#9Q#1R#+R##"
      Change$ = Change$ + "bbb"
      OUT &H3C8, 0
      FOR Loops = 0 TO 255
         Red = ASC(MID$(Change$, Loops * 3 + 1, 1)) - 35
         green = ASC(MID$(Change$, Loops * 3 + 2, 1)) - 35
         Blue = ASC(MID$(Change$, Loops * 3 + 3, 1)) - 35
         ColorPalette(Loops, 1) = Red
         ColorPalette(Loops, 2) = green
         ColorPalette(Loops, 3) = Blue
         OUT &H3C9, Red
         OUT &H3C9, green
         OUT &H3C9, Blue
      NEXT Loops
      Change$ = ""
   END IF
ELSE
   IF BitsPerPixel = 1 OR BitsPerPixel = 4 THEN
      SCREEN 12
   ELSE
      SCREEN 13
   END IF
   NoOfColors = 2 ^ BitsPerPixel
   Palette$ = SPACE$(NoOfColors * BytesPerPalette)
   GET #255, , Palette$
   OUT &H3C8, 0
   FOR Loops = 0 TO NoOfColors - 1
      IF BitsPerPixel = 1 AND Loops = 1 THEN
         OUT &H3C8, 15
      END IF
      OUT &H3C9, ASC(MID$(Palette$, Loops * BytesPerPalette + 3, 1)) \ 4
      OUT &H3C9, ASC(MID$(Palette$, Loops * BytesPerPalette + 2, 1)) \ 4
      OUT &H3C9, ASC(MID$(Palette$, Loops * BytesPerPalette + 1, 1)) \ 4
   NEXT Loops
END IF

Movements = 20
IF BMPHeader.OffsetOfBitMap <> 0 THEN
   SEEK #255, BMPHeader.OffsetOfBitMap + 1
END IF

ByteCopy = ImageWidth
IF ImageWidth > 320 THEN
   ByteCopy = 320
END IF

IF Compression = 0 THEN
   Extract = (BitsPerPixel / 8) * ImageWidth
   IF (Extract MOD 4) <> 0 THEN
      Extract = Extract + (4 - (Extract MOD 4))
   END IF
   Extract$ = SPACE$(Extract)
   DO
   IF BMPHeader.OffsetOfBitMap <> 0 THEN
      SEEK #255, BMPHeader.OffsetOfBitMap + 1
   END IF
   FOR YHeight = ImageHeight - 1 TO 0 STEP -1
      GET #255, , Extract$
      IF BitsPerPixel = 1 THEN
         FOR XWidth = 0 TO Extract - 1
            Byte = ASC(MID$(Extract$, XWidth + 1, 1))
            FOR EachByte = 7 TO 0 STEP -1
               IF XWidth * 8 + (7 - EachByte) > ImageWidth THEN EXIT FOR
               IF (Byte AND 2 ^ EachByte) <> 0 THEN
                  PSET (XWidth * 8 + (7 - EachByte), YHeight), 15
               ELSE
                  PSET (XWidth * 8 + (7 - EachByte), YHeight), 0
               END IF
            NEXT EachByte
         NEXT XWidth
      ELSEIF BitsPerPixel = 4 THEN
         FOR XWidth = 0 TO (ImageWidth / 2) - 1
            Byte = ASC(MID$(Extract$, XWidth + 1, 1))
            PSET (XWidth * 2, YHeight), Byte \ 16
            PSET (XWidth * 2 + 1, YHeight), Byte AND 15
         NEXT XWidth
      ELSEIF BitsPerPixel = 8 THEN
         IF (YHeight - ImageHM) < 101 AND (YHeight - ImageHM) > -1 THEN
            CALL MemCopyBD(VARSEG(Extract$), SADD(Extract$) + ImageWM, &HA000, (YHeight - ImageHM) * 320, ByteCopy)
         ELSEIF (YHeight - ImageHM) < 201 AND (YHeight - ImageHM) > 99 THEN
            CALL MemCopyBD(VARSEG(Extract$), SADD(Extract$) + ImageWM, &HA7D0, (YHeight - 100 - ImageHM) * 320, ByteCopy)
         END IF
         IF (YHeight - ImageHM) < 0 THEN EXIT FOR
      ELSEIF BitsPerPixel = 16 AND Greyscale = 1 THEN
         FOR XWidth = 0 TO ImageWidth - 1
            Bit16 = CVI(MID$(Extract$, XWidth * 2 + 1, 2))
            Red = Bit16 AND 31: Bit16 = Bit16 \ 32
            green = Bit16 AND 63: Bit16 = Bit16 \ 64
            Blue = Bit16
            PSET (XWidth, YHeight), (Red + (green \ 2) + Blue) \ 3
         NEXT XWidth
      ELSEIF BitsPerPixel = 16 AND Greyscale = 0 THEN
         FOR XWidth = 0 TO ImageWidth - 1
            Bit16 = CVI(MID$(Extract$, XWidth * 2 + 1, 2))
            Red = (Bit16 AND 31) * 2: Bit16 = Bit16 \ 32
            green = Bit16 AND 63: Bit16 = Bit16 \ 64
            Blue = Bit16 * 2
            PSET (XWidth, YHeight), ClosestColor(Red, green, Blue)
         NEXT XWidth
      ELSEIF BitsPerPixel = 24 AND Greyscale = 1 THEN
         FOR XWidth = 0 TO ImageWidth - 1
            Red = ASC(MID$(Extract$, XWidth * 3 + 1, 1))
            green = ASC(MID$(Extract$, XWidth * 3 + 2, 1))
            Blue = ASC(MID$(Extract$, XWidth * 3 + 3, 1))
            PSET (XWidth, YHeight), (Red + green + Blue) \ 3
         NEXT XWidth
      ELSEIF BitsPerPixel = 24 AND Greyscale = 0 THEN
         FOR XWidth = 0 TO ImageWidth - 1
            Red = ASC(MID$(Extract$, XWidth * 3 + 3, 1)) \ 4
            green = ASC(MID$(Extract$, XWidth * 3 + 2, 1)) \ 4
            Blue = ASC(MID$(Extract$, XWidth * 3 + 1, 1)) \ 4
            PSET (XWidth, YHeight), ClosestColor(Red, green, Blue)
         NEXT XWidth
      END IF
   NEXT YHeight
   IF Continue = 0 THEN
      WHILE INKEY$ <> "": WEND
      DO
         Wait$ = INKEY$
      LOOP WHILE Wait$ = ""
   END IF
   IF BitsPerPixel <> 8 THEN EXIT DO
   IF INKEY$ <> "" THEN Continue = 0: Wait$ = ""
   IF Wait$ = "4" OR Wait$ = CHR$(0) + CHR$(&H4B) THEN
      ImageWM = ImageWM - Movements: Continue = 1
   ELSEIF Wait$ = "2" OR Wait$ = CHR$(0) + CHR$(&H50) THEN
      ImageHM = ImageHM + Movements: Continue = 1
   ELSEIF Wait$ = "6" OR Wait$ = CHR$(0) + CHR$(&H4D) THEN
      ImageWM = ImageWM + Movements: Continue = 1
   ELSEIF Wait$ = "8" OR Wait$ = CHR$(0) + CHR$(&H48) THEN
      ImageHM = ImageHM - Movements: Continue = 1
   END IF

   IF ImageWM < -1 THEN
      ImageWM = 0: Continue = 0
   ELSEIF ImageHM < -1 THEN
      ImageHM = 0: Continue = 0
   ELSEIF (ImageHM + 200) > ImageHeight THEN
      ImageHM = ImageHeight - 200: Continue = 0
   ELSEIF (ImageWM + 320) > ImageWidth THEN
      ImageWM = ImageWidth - 320: Continue = 0
   END IF

   LOOP UNTIL Wait$ = CHR$(32)
ELSE
   PixelColors$ = SPACE$(1): NoOfSameColors$ = SPACE$(1)
   RightMovement$ = SPACE$(1): UpMovement$ = SPACE$(1)
   x = 0: y = ImageHeight - 1
   DO
      GET #255, , NoOfSameColors$
      GET #255, , PixelColors$
      NoOfSameColors = ASC(NoOfSameColors$)
      PixelColor = ASC(PixelColors$)
      IF NoOfSameColors <> 0 THEN
         IF BitsPerPixel = 8 THEN
            LINE (x, y)-STEP(ASC(NoOfSameColors$), 0), PixelColor
            x = x + NoOfSameColors
         ELSE
            Pixel1 = PixelColor \ 16
            Pixel2 = PixelColor AND 15
            FOR Loops = 1 TO NoOfSameColors STEP 2
               PSET (x, y), Pixel1
               PSET (x + 1, y), Pixel2
               x = x + 2
            NEXT Loops
            IF (NoOfSameColors MOD 2) = 1 THEN x = x - 1
         END IF
      ELSEIF NoOfSameColors = 0 AND PixelColor = 0 THEN
         x = 0: y = y - 1
      ELSEIF NoOfSameColors = 0 AND PixelColor = 1 THEN
         EXIT DO
      ELSEIF NoOfSameColors = 0 AND PixelColor = 2 THEN
         GET #255, , RightMovement$
         GET #255, , UpMovement$
         x = x + ASC(RightMovement$): y = y + ASC(UpMovement$)
      ELSEIF NoOfSameColors = 0 THEN
         PixelColor$ = SPACE$(PixelColor * (BitsPerPixel / 8))
         GET #255, , PixelColor$
         IF BitsPerPixel = 8 THEN
            IF y < 101 AND y > -1 THEN
               CALL MemCopyBD(VARSEG(PixelColor$), SADD(PixelColor$), &HA000, (y * 320) + x, PixelColor)
            ELSEIF y < 201 AND y > 100 THEN
               CALL MemCopyBD(VARSEG(PixelColor$), SADD(PixelColor$), &HA7D0, ((y - 100) * 320) + x, PixelColor)
            END IF
            x = x + PixelColor
            IF (PixelColor MOD 2) = 1 THEN GET #255, , NoOfSameColors$
         ELSE
            FOR Loops = 1 TO LEN(PixelColor$)
               PicColor = ASC(MID$(PixelColor$, Loops, 1))
               PSET (x, y), PicColor \ 16
               PSET (x + 1, y), PicColor AND 15
               x = x + 2
            NEXT Loops
            IF (PixelColor MOD 2) = 1 THEN x = x - 1
            IF ((Loops - 1) MOD 2) = 1 THEN GET #255, , NoOfSameColors$
         END IF
      END IF
   LOOP
   Wait$ = INPUT$(1)
END IF
CLOSE

END SUB

